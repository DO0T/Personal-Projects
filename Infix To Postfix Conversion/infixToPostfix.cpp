/*
 * Name: Dawson Tomes
 * Date Submitted: 2/3/23
 * Lab Section: Section 1
 * Assignment Name: Lab 2: Infix to Postfix Conversion
 */

#include <string>
#include <stack>
#include <iostream>

using namespace std;

//Converts an infix arithmetic expression into postfix
//The function takes 3 parameters
//First parameter: array of strings for infix expression
//    each string is either an integer number or operator symbol
//Second parameter: number of strings in infix expression
//Third parameter: array of strings for postfix expression
//    generated by function, same format as first parameter
//    assumes that postfix is at least the size of postfix



//Any string in infix may be assumed to be an integer operand if none
// of the above symbols




// * : multiplication, higher precedence - takes place before "+" and "-"
// / : division, higher precedence - takes place before "+" and "-"
// % : remainder, higher precedence - takes place before "+" and "-"
// + : addition, lower precedence - takes place after "*" , "/" , "%"
// - : subtraction, lower precedence - takes place after "*" , "/" , "%"
int orderPrecedence(char symbolOp) 
{
    int precedence = 0;
    //Precedence is based on the order of operations DMAS
    //The function is not specified to work with any other operator symbols
    if (symbolOp == '/' || symbolOp == '*' || symbolOp == '%') 
    {
        precedence = 2;
        return precedence; //highest precedence
    }
    else if (symbolOp == '+' || symbolOp == '-') 
    {
        precedence = 1;
        return precedence; // lower precedence 
    }
    else 
    {
        return precedence; // no precedence or undefined operator
    }
}

//Return value: int, number of strings in postfix expression
//    Returns 0 if an error is encountered when converting expression
//    An error occurs with a mismatched parenthesis, e.g. ( ( ) or ( ) ) etc.
//Operator symbols:
// ( : left parenthesis, all operations between this and ")" take place first
// ) : right parenthesis, all op.s back to previous "(" take place first

bool InfixValidation(string array[], int arrayLength)
{
    stack<string> stack;
    string tempString;

    for (int j = 0; j < arrayLength; ++j) 
    {
        if (array[j][0] == '(') // checks to see if the expression starts with (. (if thats the case, the operations within () are 
        {                       //pushed to the stack first.
            stack.push(array[j]); // pushes the current index of array to the stack

            continue; // breaks the iteration of the loop and starts a new iteration 
        }
        else if (array[j][0] == ')')
        {
            if (stack.empty())  // checks if the stack is empty 
            {
                return 0;
            }
            tempString = stack.top();
            stack.pop(); // removes the top (first) element in the stack
        }
    }
    return stack.empty(); 
}
int infixToPostfix(string infix[], int length, string postfix[])
{
    string stringIndex;
    string conditional = "C";
 
    stack<string> stack; // creates a string stack
    stack.push(conditional); // used for conditional logic later in the function

    int index = 0; // keeps track of the length
 
    if (!InfixValidation(infix, length)) // if the infix is invalid return 0
    {
        return 0;  // returns 0 if there is an error
    }

    for (int j = 0; j < length; ++j) 
    {
        if (isdigit(infix[j][0])) // isdigit checks to see if a character is a digit or not
                                  // so in this case we're checking the element in the array at position j to see if it is a digit
        {
            postfix[index++] = infix[j]; // if it is a digit increment the index and add the number to the postfix expression 
        }
        else if (infix[j][0] == '(') 
        {
            stack.push(infix[j]);
        }
        else if (infix[j][0] == ')') // checks for right parenthesis
        {
            while (stack.top()[0] != '(' && stack.top()[0] != 'C')  //if the first element in the stack is != to (
            {
                stringIndex = stack.top();
                //stack.pop removes the first (top) element in the stack
                stack.pop();

                postfix[index++] = stringIndex;
            }
            switch (stack.top()[0]) 
            {
                case '(': // if the first element of the stack is = to (
                    stack.pop(); //removes (
                default:
                    break; // no such case (
            }
        }
        else 
        {
            for (stringIndex = stack.top(); orderPrecedence(infix[j][0]) <= orderPrecedence(stringIndex[0]) && stringIndex[0] != 'C'; stringIndex = stack.top())
            { // this for loop is similar to the other while loops excpet it deals with lower precedence
                stack.pop();

                postfix[index++] = stringIndex;
            }
            stack.push(infix[j]);
        }
    }
    for (stringIndex = stack.top(); stringIndex[0] != 'C'; stringIndex = stack.top()) // this code pops the rest of the elements in the stack that were not already popped
    {
        stack.pop();

        postfix[index++] = stringIndex;
    }
    return index; // returns the length
}

////Main function to test infixToPostfix()
////Should convert 2 + 3 * 4 + ( 5 - 6 + 7 ) * 8
////            to 2 3 4 * + 5 6 - 7 + 8 * +
//int main()
//{
//    string infixExp[] = {"2", "+", "3", "*", "4", "+", "(",
//                         "5", "-", "6", "+", "7", ")", "*",
//                         "8"};
//    string postfixExp[15];
//    int postfixLength;
//
//    cout << "Infix expression: ";
//    for (int i=0; i<15; i++)
//    {
//        cout << infixExp[i] << " ";
//    }
//    cout << endl;
//    cout << "Length: 15" << endl << endl;
//
//    postfixLength = infixToPostfix(infixExp, 15, postfixExp);
//
//    cout << "Postfix expression: ";
//    for (int i=0; i<postfixLength; i++)
//    {
//        cout << postfixExp[i] << " ";
//    }
//    cout << endl;
//    cout << "Length: " << postfixLength << endl;
//    
//    return 0;
//}